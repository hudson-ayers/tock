use kernel::syscall::Syscall;
/// This file contains a mapping of in-kernel paths to WCET measurements for
/// use by the secure time scheduler. Eventually, these will be
/// generated by an external tool.
use kernel::KernelTask;

const NUM_INTERRUPTS: usize = 12;
pub const INTERRUPT_TOP_HALF_WCETS_US: [u32; NUM_INTERRUPTS] = [2; NUM_INTERRUPTS];
pub const INTERRUPT_BOTTOM_HALF_WCETS_US: [u32; NUM_INTERRUPTS] = [10000; NUM_INTERRUPTS];

const NUM_VARIABLE_SYSCALLS: usize = 5;
const NUM_SYSCALL_DRIVERS: usize = 5; //# items in Platform struct
pub const SYSCALL_WCETS: [[u32; NUM_VARIABLE_SYSCALLS]; NUM_SYSCALL_DRIVERS] =
    [[0; NUM_VARIABLE_SYSCALLS]; NUM_SYSCALL_DRIVERS];

const NUM_MEMOP_CALLS: usize = 12;
const MEMOP_WCETS: [u32; NUM_MEMOP_CALLS] = [100; NUM_MEMOP_CALLS];

/// Used to abstract away interface for retreiving task WCET from
/// underlying mechanism for storing that data.
/// Panics if wcet info unavailable.
pub const fn get_task_wcet(task: KernelTask) -> u32 {
    match task {
        KernelTask::BottomHalfInterrupt { interrupt } => {
            INTERRUPT_BOTTOM_HALF_WCETS_US[interrupt as usize]
        }
        KernelTask::TopHalfInterrupt { interrupt } => {
            INTERRUPT_TOP_HALF_WCETS_US[interrupt as usize]
        }
        KernelTask::SystemCall(syscall) => {
            let (syscall_num, driver_num) = match syscall {
                Syscall::Yield { .. } => return 1, // TODO: Verify
                Syscall::Subscribe { driver_number, .. } => (1, driver_number),
                Syscall::Command { driver_number, .. } => (2, driver_number),
                Syscall::ReadWriteAllow { driver_number, .. } => (3, driver_number),
                Syscall::ReadOnlyAllow { driver_number, .. } => (4, driver_number),
                Syscall::Memop { operand, .. } => return MEMOP_WCETS[operand],
                Syscall::Exit { .. } => return 1, // TODO: Verify
            };
            return SYSCALL_WCETS[driver_num][syscall_num - 1];
        }
    }
}
